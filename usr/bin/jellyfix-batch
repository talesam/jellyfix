#!/bin/bash
#
# jellyfix-batch - Processa m√∫ltiplas pastas em paralelo
#
# Uso: jellyfix-batch [op√ß√µes] pasta1 pasta2 pasta3 ...
#

set -e

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Configura√ß√µes padr√£o
MAX_JOBS=5
DRY_RUN=false
VERBOSE=false
LOG_DIR="/tmp/jellyfix-logs"
USE_FFPROBE=false

# Fun√ß√£o de ajuda
show_help() {
    cat << EOF
${BOLD}jellyfix-batch${NC} - Processa m√∫ltiplas pastas de m√≠dia em paralelo

${BOLD}USO:${NC}
    jellyfix-batch [op√ß√µes] pasta1 pasta2 pasta3 ...

${BOLD}OP√á√ïES:${NC}
    -j, --jobs NUM        N√∫mero de jobs paralelos (padr√£o: 5)
    -n, --dry-run         Modo simula√ß√£o (n√£o modifica arquivos)
    -v, --verbose         Sa√≠da detalhada
    -l, --log-dir DIR     Diret√≥rio para logs (padr√£o: /tmp/jellyfix-logs)
    -f, --ffprobe         Usar ffprobe para detec√ß√£o de qualidade
    -h, --help            Mostrar esta ajuda

${BOLD}EXEMPLOS:${NC}
    # Processar 3 pastas no diret√≥rio atual
    jellyfix-batch Serie1 Serie2 Filme1

    # Processar com caminhos absolutos
    jellyfix-batch /media/Series/BreakingBad /media/Filmes/Matrix

    # Processar 10 pastas em paralelo (modo dry-run)
    jellyfix-batch -j 10 -n Serie*

    # Processar com ffprobe e verbose
    jellyfix-batch -v -f Serie1 Serie2

${BOLD}NOTAS:${NC}
    ‚Ä¢ Caminhos relativos s√£o expandidos automaticamente
    ‚Ä¢ Logs salvos em: ${LOG_DIR}/
    ‚Ä¢ Configura√ß√µes em: ~/.jellyfix/config.json
    ‚Ä¢ Use Ctrl+C para cancelar

EOF
}

# Parse argumentos
POSITIONAL_ARGS=()
while [[ $# -gt 0 ]]; do
    case $1 in
        -j|--jobs)
            MAX_JOBS="$2"
            shift 2
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -l|--log-dir)
            LOG_DIR="$2"
            shift 2
            ;;
        -f|--ffprobe)
            USE_FFPROBE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo -e "${RED}Erro: Op√ß√£o desconhecida $1${NC}" >&2
            echo "Use --help para ver op√ß√µes dispon√≠veis"
            exit 1
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

# Restaurar argumentos posicionais
set -- "${POSITIONAL_ARGS[@]}"

# Verificar se tem argumentos
if [ $# -eq 0 ]; then
    echo -e "${RED}Erro: Nenhuma pasta especificada${NC}" >&2
    echo ""
    show_help
    exit 1
fi

# Criar diret√≥rio de logs
mkdir -p "$LOG_DIR"

# Banner
echo -e "${BOLD}${CYAN}"
echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë          üé¨  JELLYFIX BATCH PROCESSOR  üé¨                ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
echo -e "${NC}"

# Mostrar configura√ß√£o
echo -e "${BOLD}‚öôÔ∏è  Configura√ß√£o:${NC}"
echo -e "  Jobs paralelos: ${CYAN}$MAX_JOBS${NC}"
echo -e "  Modo: ${CYAN}$([ "$DRY_RUN" = true ] && echo "DRY-RUN (simula√ß√£o)" || echo "EXECUTE (modifica arquivos)")${NC}"
echo -e "  Verbose: ${CYAN}$([ "$VERBOSE" = true ] && echo "Sim" || echo "N√£o")${NC}"
echo -e "  FFprobe: ${CYAN}$([ "$USE_FFPROBE" = true ] && echo "Sim" || echo "N√£o")${NC}"
echo -e "  Logs: ${CYAN}$LOG_DIR${NC}"
echo ""

# Array para armazenar pastas v√°lidas
declare -a VALID_DIRS=()

# Validar pastas
echo -e "${BOLD}üìÅ Validando pastas...${NC}"
for dir in "$@"; do
    # Converter caminho relativo para absoluto
    if [[ "$dir" = /* ]]; then
        # J√° √© absoluto
        full_path="$dir"
    else
        # Relativo - expandir usando realpath ou fallback
        if command -v realpath &> /dev/null; then
            full_path="$(realpath -m "$dir" 2>/dev/null)" || full_path="$PWD/$dir"
        else
            # Fallback se realpath n√£o existir
            full_path="$PWD/$dir"
        fi
    fi

    # Verificar se existe e √© diret√≥rio
    if [ ! -d "$full_path" ]; then
        echo -e "  ${YELLOW}‚ö†${NC}  Pulando (n√£o existe): $dir ‚Üí $full_path"
    else
        VALID_DIRS+=("$full_path")
        echo -e "  ${GREEN}‚úì${NC}  $(basename "$full_path") ‚Üí $full_path"
    fi
done

# Verificar se tem pastas v√°lidas
if [ ${#VALID_DIRS[@]} -eq 0 ]; then
    echo -e "\n${RED}Erro: Nenhuma pasta v√°lida encontrada${NC}" >&2
    exit 1
fi

echo ""
echo -e "${BOLD}üìä Total: ${#VALID_DIRS[@]} pasta(s) para processar${NC}"
echo ""

# Confirmar execu√ß√£o (se n√£o for dry-run)
if [ "$DRY_RUN" = false ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  ATEN√á√ÉO: Arquivos ser√£o MODIFICADOS!${NC}"
    read -p "Deseja continuar? (s/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Ss]$ ]]; then
        echo -e "${RED}Opera√ß√£o cancelada${NC}"
        exit 0
    fi
    echo ""
fi

# Fun√ß√£o para processar uma pasta
process_dir() {
    local dir="$1"
    local basename_dir=$(basename "$dir")
    local log_file="$LOG_DIR/$(date +%Y%m%d_%H%M%S)_${basename_dir}.log"

    # Construir comando jellyfix
    local cmd="jellyfix --workdir '$dir' --non-interactive --yes"

    # Adicionar flags
    if [ "$DRY_RUN" = true ]; then
        cmd="$cmd --dry-run"
    else
        cmd="$cmd --execute"
    fi

    if [ "$VERBOSE" = true ]; then
        cmd="$cmd --verbose"
    fi

    if [ "$USE_FFPROBE" = true ]; then
        cmd="$cmd --use-ffprobe"
    fi

    cmd="$cmd --log '$log_file'"

    # Executar
    echo -e "${BLUE}‚ñ∂${NC}  Iniciando: ${BOLD}$basename_dir${NC}"

    if eval $cmd > /dev/null 2>&1; then
        echo -e "${GREEN}‚úÖ${NC} Conclu√≠do: ${BOLD}$basename_dir${NC} ‚Üí Log: $log_file"
        return 0
    else
        local exit_code=$?
        echo -e "${RED}‚ùå${NC} Erro em: ${BOLD}$basename_dir${NC} (c√≥digo: $exit_code) ‚Üí Log: $log_file"
        return $exit_code
    fi
}

# Exportar fun√ß√£o e vari√°veis para subshells
export -f process_dir
export DRY_RUN VERBOSE USE_FFPROBE LOG_DIR
export RED GREEN YELLOW BLUE MAGENTA CYAN BOLD NC

# Hora de in√≠cio
START_TIME=$(date +%s)

echo -e "${BOLD}üöÄ Iniciando processamento...${NC}"
echo ""

# Verificar se GNU Parallel est√° dispon√≠vel
if command -v parallel &> /dev/null; then
    # Usar GNU Parallel
    echo -e "${CYAN}‚Ñπ${NC}  Usando GNU Parallel"

    printf '%s\n' "${VALID_DIRS[@]}" | \
        parallel -j "$MAX_JOBS" --line-buffer process_dir {}

    PARALLEL_EXIT=$?
else
    # Fallback: usar jobs do bash
    echo -e "${CYAN}‚Ñπ${NC}  GNU Parallel n√£o encontrado, usando jobs do bash"

    FAILED=0
    TOTAL=${#VALID_DIRS[@]}
    COMPLETED=0

    for dir in "${VALID_DIRS[@]}"; do
        # Aguardar se j√° tem MAX_JOBS rodando
        while [ $(jobs -r | wc -l) -ge $MAX_JOBS ]; do
            sleep 0.5
        done

        # Processar em background
        process_dir "$dir" &
    done

    # Aguardar todos terminarem
    wait
    PARALLEL_EXIT=$?
fi

# Hora de fim
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

# Resumo
echo ""
echo -e "${BOLD}${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo -e "${BOLD}üìä Resumo${NC}"
echo -e "${BOLD}${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo ""

# Contar sucessos e falhas nos logs
SUCCESS_COUNT=0
FAIL_COUNT=0

shopt -s nullglob  # Evita problemas se n√£o houver logs
for log in "$LOG_DIR"/*.log; do
    if [ -f "$log" ] && grep -q "opera√ß√µes planejadas" "$log" 2>/dev/null; then
        ((SUCCESS_COUNT++)) || true
    elif [ -f "$log" ]; then
        ((FAIL_COUNT++)) || true
    fi
done
shopt -u nullglob

echo -e "  Pastas processadas: ${CYAN}${#VALID_DIRS[@]}${NC}"
echo -e "  Tempo total: ${CYAN}${DURATION}s${NC}"
echo -e "  Logs salvos em: ${CYAN}$LOG_DIR${NC}"
echo ""

if [ $PARALLEL_EXIT -eq 0 ]; then
    echo -e "${GREEN}${BOLD}üéâ Processamento conclu√≠do com sucesso!${NC}"
else
    echo -e "${YELLOW}${BOLD}‚ö†Ô∏è  Processamento conclu√≠do com alguns erros${NC}"
    echo -e "${YELLOW}   Verifique os logs para detalhes${NC}"
fi

echo ""
echo -e "${BOLD}üí° Dica:${NC} Para ver os logs:"
echo -e "   ${CYAN}ls -lh $LOG_DIR/${NC}"
echo -e "   ${CYAN}tail -f $LOG_DIR/*.log${NC}"
echo ""

exit $PARALLEL_EXIT
